<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>AoC 2021</title> <div id=layout > <div id=menu > <ul> <li><a href="/">Home</a> <li><a href="/blogposts/">Blog</a> </ul> </div> <div id=main > <div class=franklin-content ><h1 id=my_favourite_advent_of_code_2021_puzzle ><a href="#my_favourite_advent_of_code_2021_puzzle" class=header-anchor >My favourite Advent of Code 2021 Puzzle</a></h1> <div class=franklin-toc ><ol><li><a href="#what_is_advent_of_code">What is Advent Of Code?</a><li><a href="#day_22">Day 22 </a><ol><li><a href="#the_puzzle">The puzzle</a><li><a href="#my_solution">My solution</a></ol></ol></div> <h2 id=what_is_advent_of_code ><a href="#what_is_advent_of_code" class=header-anchor >What is Advent Of Code?</a></h2> <div class=marginnote >Although this is probably not needed for the audience of my blog.</div> <p>First, maybe a short introduction what <a href="https://adventofcode.com">Advent of Code</a> even is. Essentially, it is an advent calendar consisting of 25 coding puzzles. The cool part is that everyone gets a personalized input every day and has to submit the requested solution for his/her data.<br />The puzzles start out quite easy and become more and more challenging over the duration of december. Additionally each day consists of two parts. The second part gets only revealed after solving the first one. So, one should be careful going for a greedy first solution.<br />Two more short notes, how I solved those puzzles.</p> <div class=marginnote >Or any other library that allows python to call C code.</div> <ul> <li><p>Since 2020, I used <a href="https://julialang.org">Julia</a> for all puzzles. Coming from a python background, after a small adaption time it is a joy not having to rely on numpy when coding fast implementations.</p> <li><p>At least the second half of the puzzles, I solved together with my Dad. It made me realize how good pair-programming can be. Actively talking about the design of the solution, as well as having two pair of eyes looking for bugs, led in my experience to a better code style and more correct solutions.</p> </ul> <h2 id=day_22 ><a href="#day_22" class=header-anchor >Day 22 </a></h2> <div class=marginnote >You can find the full explanation and examples by clicking on day 22 to the left.</div> <p>I liked many puzzles last year &#40;2021&#41;, but I found <a href="https://adventofcode.com/2021/day/22">day 22</a> especially pleasing.</p> <h3 id=the_puzzle ><a href="#the_puzzle" class=header-anchor >The puzzle</a></h3> <div class=marginnote >Voxels are the 3D equivalent of what pixels are for 2D.</div> <p>The puzzle instructions were a list of 3d cuboids, which turn every voxel inside of them either <strong>on</strong> or <strong>off</strong>. An example input could look like the following:</p> <div class=marginnote >I constructed this example such that all cuboids are planes in the x-y dimension. Now i can visualize them in 2D and still be correct.</div> <blockquote> <p>on x&#61;-8..7,y&#61;-13..-5,z&#61;12..12<br />on x&#61;18..28,y&#61;-7..3,z&#61;-12..12<br />off x&#61;-2..23,y&#61;-10..1,z&#61;-12..12</p> </blockquote> <p>Visualized, the 2D x-y part of those three steps look like the following:</p> <div class=marginnote >For the purpose of simplicity visualizations will only be in 2D, yet we will quickly realize that the solution scales to an arbitrary number of dimensions.<br />All white pixels are also off, the red ones are only to indicate that there is an explicit command, to turn them off.</div> <p><img src="/assets/blogposts/AoC2021/overlap.png" alt="overlapping on and off" /></p> <p>In the beginning all voxels are off. The question is then, how many voxels are <strong>on</strong> after all cuboids.<br />In the little toy example above, the answer would be 155.<br />The first part of the puzzle was only about the voxels in a certain subspace of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant=double-struck >R</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb R^3</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord ><span class="mord mathbb">R</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>, but I will instantly talk about the solution for all voxels.</p> <h3 id=my_solution ><a href="#my_solution" class=header-anchor >My solution</a></h3> <p>The brute force solution would be to keep track of the status of every voxel and update its status for every cuboid. This approach quickly breaks down after seeing that the space where one needs to keep track of voxels is at least 100000 in x, y and z.</p> <div class=marginnote >The division by 8 is because every voxel only needs to store 1 Bit &#40;on / off&#41; and the right side is in Byte</div> <p>This corresponds to <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>10000</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><mn>8</mn></mfrac><mo>=</mo><mn>125</mn><mi>T</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">\frac{100000^3}{8}=125TB</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.36292em;vertical-align:-0.345em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10000</span><span class="mord mtight"><span class="mord mtight">0</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class=pstrut  style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >125</span><span class="mord mathnormal" style="margin-right:0.05017em;">TB</span></span></span></span> of memory needed.</p> <p>The first simplification is that we only need to keep track of the voxels that are on. And we can even optimize further by always saving entire regions / cuboids that are on instead of single voxels. Let us first define a few structures and type aliases which we need:</p> <pre><code class="julia hljs">Cuboid = <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int</span>},<span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int</span>},<span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int</span>}}
NonOLCuboids = <span class=hljs-built_in >Vector</span>{Cuboid} <span class=hljs-comment ># stands for Non-overlapping</span>

<span class=hljs-comment ># every input line was called a command,</span>
<span class=hljs-comment ># consisting of the cuboid itself and the information whether it is on or off</span>
<span class=hljs-keyword >struct</span> Command
    cube::Cuboid
    turn_on::<span class=hljs-built_in >Bool</span>
<span class=hljs-keyword >end</span></code></pre> <p>This implementation of a cuboid as a Tuple of <code>UnitRanges</code> and the respective structure for non overlapping cuboids allow us to directly calculate their volume:</p> <pre><code class="julia hljs">volume(c::Cuboid) = prod(length.(c))
volume(nolc::NonOLCuboids) = sum(volume.(nolc))</code></pre> <p>The next logical question is, how do we handle cuboid intersections?<br />First, we need to calculate the intersection volume of two cuboids. Important to note is that an intersection of two cuboids is again a cuboid. With our representation of cuboids, the function for calculating them is pretty straight forward.</p> <div class=marginnote >The function is called Base.intersect to ensure that we do not hide the intersect function defined in julia&#39;s Base.</div> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> Base.intersect(c1::Cuboid, c2::Cuboid) 
    t = (intersect(c1[i],c2[i]) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >3</span>)
    any(r -&gt; length(r)==<span class=hljs-number >0</span>, t) &amp;&amp; <span class=hljs-keyword >return</span> <span class=hljs-literal >nothing</span>
    Cuboid(t)
<span class=hljs-keyword >end</span></code></pre> <p>The idea, how to handle intersections is the following: If a new cuboid intersects with an existing one, we keep the new one and remove the intersection out of the old one. Since we only store cuboids, we need to split the existing one into mulitple other ones. The split we want to achieve looks like this:</p> <p><img src="/assets/blogposts/AoC2021/split.png" alt="split example" /></p> <p>The 5 cuboids look a little bit redundant? Why don&#39;t we merge cuboid 1, 2 and 3, or cuboid 1 and 4? The answer is that this split is easy to compute for an arbitrary intersect and even for any number of dimensions. To achieve this split, we compute the following segments for each dimension. </p> <ul> <li><p>The intersect in the respective dimension; &#91;<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>inter</mtext><mtext>start</mtext></msub><mo>:</mo><msub><mtext>inter</mtext><mtext>end</mtext></msub></mrow><annotation encoding="application/x-tex">\text{inter}_\text{start} : \text{inter}_\text{end}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.81786em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord text"><span class=mord >inter</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">start</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >:</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.81786em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord text"><span class=mord >inter</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">end</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&#93;</p> <li><p>If the start of the old cuboid is more to the left, than the intersect, then we add the segment between the start of the old cuboid and the intersect; if <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>cub</mtext><mtext>start</mtext></msub><mo>&lt;</mo><msub><mtext>inter</mtext><mtext>start</mtext></msub></mrow><annotation encoding="application/x-tex">\text{cub}_\text{start} &lt; \text{inter}_\text{start}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord text"><span class=mord >cub</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">start</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >&lt;</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.81786em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord text"><span class=mord >inter</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">start</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, add &#91;<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>cub</mtext><mtext>start</mtext></msub><mo>:</mo><msub><mtext>inter</mtext><mtext>start</mtext></msub></mrow><annotation encoding="application/x-tex">\text{cub}_\text{start} : \text{inter}_\text{start}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord text"><span class=mord >cub</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">start</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >:</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.81786em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord text"><span class=mord >inter</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">start</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&#93;</p> <li><p>If the end of the old cuboid is more to the right, than the intersect, then we add the segment between the end of the intersect and the old cuboid; if <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>cub</mtext><mtext>end</mtext></msub><mo>&gt;</mo><msub><mtext>inter</mtext><mtext>end</mtext></msub></mrow><annotation encoding="application/x-tex">\text{cub}_\text{end} &gt; \text{inter}_\text{end}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord text"><span class=mord >cub</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">end</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >&gt;</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.81786em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord text"><span class=mord >inter</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">end</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, add &#91;<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>inter</mtext><mtext>end</mtext></msub><mo>:</mo><msub><mtext>cub</mtext><mtext>end</mtext></msub></mrow><annotation encoding="application/x-tex">\text{inter}_\text{end} : \text{cub}_\text{end}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.81786em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord text"><span class=mord >inter</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">end</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >:</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord text"><span class=mord >cub</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">end</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&#93;</p> </ul> <p>The desribed segments for the example above are:</p> <blockquote> <p>x: 1:2, 3:13, 14:16<br />y: 1:2, 3:9</p> </blockquote> <div class=marginnote >The cartesian product of two sets contains all unique combinations of two elements. In this case, they are &#91;&#40;1:2, 1:2&#41;, &#40;3:13, 1:2&#41;, &#40;14:16, 1:2&#41;, &#40;1:2, 3:9&#41;, &#40;3:13, 3:9&#41;, &#40;14:16, 3:9&#41;&#93;</div> <p>The splitted cuboids are the cartesian product of those segments of all &#40;three&#41; dimensions, excluded the one where all segments are the intersect segment.<br />In Julia an implementation for this split might look like this:</p> <pre><code class="julia hljs"><span class=hljs-keyword >struct</span> Section
    segment::<span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int</span>}
    is_intersect::<span class=hljs-built_in >Bool</span>
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> split_dimension(old_section::<span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int</span>}, new_section::<span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int</span>})
    splitted = [Section(new_section,<span class=hljs-literal >true</span>)]
    <span class=hljs-keyword >if</span> new_section[<span class=hljs-number >1</span>] &gt; old_section[<span class=hljs-number >1</span>]
        push!(splitted, Section(old_section[<span class=hljs-number >1</span>]:new_section[<span class=hljs-number >1</span>]-<span class=hljs-number >1</span>,<span class=hljs-literal >false</span>))
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >if</span> new_section[<span class=hljs-keyword >end</span>] &lt; old_section[<span class=hljs-keyword >end</span>]
        push!(splitted, Section(new_section[<span class=hljs-keyword >end</span>]+<span class=hljs-number >1</span>:old_section[<span class=hljs-keyword >end</span>],<span class=hljs-literal >false</span>))
    <span class=hljs-keyword >end</span>
    splitted
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> split_cuboid(c::Cuboid, intersect::Cuboid)
    dimensions_splits = <span class=hljs-built_in >Tuple</span>(split_dimension(c[i],intersect[i]) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >3</span>)
    splitted_cuboids = NonOLCuboids()
    <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> dimensions_splits[<span class=hljs-number >1</span>], y <span class=hljs-keyword >in</span> dimensions_splits[<span class=hljs-number >2</span>], z <span class=hljs-keyword >in</span> dimensions_splits[<span class=hljs-number >3</span>]
        all(i-&gt;i.is_intersect, (x,y,z)) &amp;&amp; <span class=hljs-keyword >continue</span>
        push!(splitted_cuboids, Cuboid((x.segment,y.segment,z.segment)))
    <span class=hljs-keyword >end</span>
    splitted_cuboids
<span class=hljs-keyword >end</span></code></pre> <p>The last step needed for the task is to iterate over all commands and in every iteration build up a new list of non overlapping cuboids. For each command, we iterate over all the non overlapping cuboids of the previous iteration and do:</p> <ul> <li><p>Keep it, if it has no intersect if the new one</p> <li><p>Split it and add all its splitted cuboids to the list, if it has an intersect with the new one</p> </ul> <p>Last but not least, the new cuboid only gets added to the list, if it is <strong>on</strong> cuboid &#40;otherwise we do not need to save it&#41;.<br />My function for this last part of the algorithm looks like this:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> execute_commands(commands)
    on_cuboids = NonOLCuboids()
    <span class=hljs-keyword >for</span> c <span class=hljs-keyword >in</span> commands
        next_on_cuboids = NonOLCuboids()
        <span class=hljs-keyword >for</span> on_c <span class=hljs-keyword >in</span> on_cuboids
            inter = intersect(c.cube, on_c)
            <span class=hljs-keyword >if</span> !isnothing(inter)
                push!(next_on_cuboids, split_cuboid(on_c, inter)...)
            <span class=hljs-keyword >else</span>
                push!(next_on_cuboids, on_c)
            <span class=hljs-keyword >end</span>
        <span class=hljs-keyword >end</span>
        <span class=hljs-keyword >if</span> c.turn_on
            push!(next_on_cuboids, c.cube)
        <span class=hljs-keyword >end</span>
        on_cuboids = next_on_cuboids
    <span class=hljs-keyword >end</span>
    volume(on_cuboids)
<span class=hljs-keyword >end</span></code></pre> <p>The full code can be found on my <a href="https://github.com/Tobias-Thomas/AdventOfCode/">github repository</a>.</p> <div class=page-foot > <div class=copyright > &copy; Tobias Thomas. Last modified: January 23, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>. </div> </div> </div> </div> </div>